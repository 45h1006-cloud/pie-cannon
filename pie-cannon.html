<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pie Cannon â€” Splatter Game</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#ffcc66;--muted:#9aa4b2}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    canvas{display:block;background:linear-gradient(180deg,#051026 0%, #08213a 60%);}
    #ui{
      position:fixed;left:12px;top:12px;padding:10px;border-radius:10px;background:rgba(255,255,255,0.03);backdrop-filter:blur(6px);color:#e6eef8;min-width:240px;z-index:1000
    }
    #ui h1{font-size:16px;margin:0 0 8px 0}
    .row{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
    .btn{background:var(--accent);color:#111;padding:6px 8px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .small{font-size:13px;color:var(--muted)}
    #instructions{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <h1>Pie Cannon ðŸ¥§</h1>
    <div class="row"><div>Splatter</div><div id="splats">0</div></div>
    <div class="row"><div>Launchers</div><div id="launchers">1</div></div>
    <div class="row"><div>Pie Tokens</div><div id="tokens">0</div></div>
    <div class="row"><div>Auto Mouse</div><button id="mouseBtn" class="btn">Buy (20)</button></div>
    <div style="margin-top:8px;display:flex;gap:8px"><button id="startBtn" class="btn">Start</button><button id="resetBtn" class="btn">Reset</button></div>
    <div id="instructions">
      Click pies to splatter them. Every 10 splats adds another pie launcher, each new one requires 30 more.
      You earn tokens per splat to buy/upgrade the auto mouse (max 2 upgrades).
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W=0,H=0;
  function resize(){
    W = canvas.width = innerWidth;
    H = canvas.height = innerHeight;
  }
  addEventListener('resize', resize);
  resize();

  // Game state
  let pies = [];
  let splats = [];
  let launchers = [];
  let splatCount = 0;
  let tokens = 0;
  let running = false;
  let cannonSpeedMultiplier = 1;
  let splatsNeededForNextCannon = 10;

  // Auto mouse state
  let mouseBought = false;
  let mouseLevel = 0; // 0=not bought, then up to 2 upgrades (max 3 levels)
  let mouseCost = 20;
  let mouseInterval = 2000;
  let mouseTimer = 0;
  let mouseHitsPerTick = 1;
  let mouseX=100, mouseY=100;

  // UI refs
  const splatsEl = document.getElementById('splats');
  const launchersEl = document.getElementById('launchers');
  const tokensEl = document.getElementById('tokens');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const mouseBtn = document.getElementById('mouseBtn');

  function rand(a,b){return a + Math.random()*(b-a)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

  class Pie{
    constructor(x,y,vx,vy,r=22){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.r=r;this.dead=false}
    update(dt){
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.y += Math.sin(this.x*0.01 + this._phase||0) * 0.2;
      if(this.x - this.r > W){ this.dead = true; }
    }
    draw(ctx){
      ctx.save();
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fillStyle = '#f2c27d'; ctx.fill();
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r*0.7, 0, Math.PI*2); ctx.fillStyle = '#8b4a2e'; ctx.fill();
      ctx.beginPath(); ctx.moveTo(this.x, this.y - this.r*0.55);
      ctx.quadraticCurveTo(this.x+10,this.y-22,this.x+4,this.y-6);
      ctx.quadraticCurveTo(this.x,this.y-32,this.x-10,this.y-8);
      ctx.fillStyle='#fff'; ctx.fill();
      ctx.restore();
    }
  }

  class Splat{
    constructor(x,y,size){this.x=x;this.y=y;this.size=size;this.particles=[];const n=rand(6,12)|0;for(let i=0;i<n;i++){this.particles.push({a:rand(0,Math.PI*2),r:rand(size*0.2,size),len:rand(size*0.2,size*1.1)})}}
    draw(ctx){
      ctx.save(); ctx.translate(this.x,this.y);
      ctx.beginPath(); ctx.arc(0,0,this.size*0.35,0,Math.PI*2); ctx.fillStyle='#7b3b1f'; ctx.fill();
      ctx.beginPath(); ctx.arc(0,0,this.size*0.55,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fill();
      for(const p of this.particles){ ctx.beginPath(); ctx.moveTo(0,0); const dx=Math.cos(p.a)*p.len; const dy=Math.sin(p.a)*p.len; ctx.lineTo(dx,dy); ctx.lineWidth= p.len*0.15; ctx.strokeStyle='rgba(123,60,30,0.9)'; ctx.stroke(); }
      ctx.restore();
    }
  }

  class Launcher{
    constructor(y,delay=1500){this.y=y;this.delay=delay;this.timer=rand(0,delay);}
    update(dt){
      this.timer += dt*1000;
      if(this.timer >= this.delay){ this.timer = 0; this.fire(); }
    }
    fire(){
      const speed = clamp(rand(180,320) * cannonSpeedMultiplier, 100, 600); // speed capped at 600
      const vy = rand(-10,10);
      const p = new Pie(40, this.y + rand(-8,8), speed, vy);
      p._phase = Math.random()*10;
      pies.push(p);
    }
  }

  function addLauncher(y,delay){
    if(launchers.length >= 7) return;
    const l = new Launcher(y, delay);
    launchers.push(l);
    launchersEl.textContent = launchers.length;
  }

  function resetGame(){
    pies=[]; splats=[]; launchers=[]; splatCount=0; tokens=0;
    cannonSpeedMultiplier=1; splatsNeededForNextCannon=10;
    mouseBought=false; mouseLevel=0; mouseCost=20; mouseInterval=2000; mouseHitsPerTick=1;
    splatsEl.textContent='0'; launchersEl.textContent='0'; tokensEl.textContent='0';
    mouseBtn.textContent='Buy (20)';
    addLauncher(H/2,1500);
  }

  startBtn.onclick = ()=>{ running = !running; startBtn.textContent = running ? 'Pause' : 'Start'; }
  resetBtn.onclick = ()=>{ running=false; startBtn.textContent='Start'; resetGame(); }

  mouseBtn.onclick = ()=>{
    if(tokens >= mouseCost){
      tokens -= mouseCost;
      tokensEl.textContent = tokens;
      if(!mouseBought){
        mouseBought = true;
        mouseLevel = 1;
        mouseBtn.textContent = 'Upgrade (40)';
        mouseCost = 40;
      } else if(mouseLevel < 3){
        mouseLevel++;
        if(mouseLevel === 2){ mouseHitsPerTick=2; mouseBtn.textContent='Upgrade (80)'; mouseCost=80; }
        else if(mouseLevel === 3){ mouseInterval=1000; mouseBtn.textContent='Maxed'; mouseCost=Infinity; }
      }
    }
  }

  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left; const cy = ev.clientY - rect.top;
    for(let i=pies.length-1;i>=0;i--){ const p = pies[i]; const dx = p.x-cx, dy = p.y-cy; if(dx*dx+dy*dy <= p.r*p.r){
        splats.push(new Splat(p.x,p.y,p.r*1.6));
        splatCount++; splatsEl.textContent = splatCount;
        tokens++; tokensEl.textContent = tokens;
        pies.splice(i,1);
        if(splatCount >= splatsNeededForNextCannon){
          const ny = clamp(rand(80,H-80), 80, H-80);
          addLauncher(ny, rand(900,2200));
          cannonSpeedMultiplier *= 1.25;
          splatsNeededForNextCannon += 30;
        }
        return; }
    }
  });

  resetGame();

  let last = performance.now();
  function loop(now){
    const dt = Math.min((now-last)/1000, 0.033); last = now;
    if(running){
      for(const l of launchers) l.update(dt);
      for(const p of pies) p.update(dt);
      pies = pies.filter(p=>!p.dead);

      if(mouseBought){
        mouseTimer += dt*1000;
        if(mouseTimer >= mouseInterval){
          mouseTimer = 0;
          for(let h=0; h<mouseHitsPerTick; h++){
            if(pies.length>0){
              const idx = (Math.random()*pies.length)|0;
              const p = pies[idx];
              splats.push(new Splat(p.x,p.y,p.r*1.6));
              splatCount++; splatsEl.textContent = splatCount;
              tokens++; tokensEl.textContent = tokens;
              pies.splice(idx,1);
              if(splatCount >= splatsNeededForNextCannon){
                const ny = clamp(rand(80,H-80), 80, H-80);
                addLauncher(ny, rand(900,2200));
                cannonSpeedMultiplier *= 1.25;
                splatsNeededForNextCannon += 30;
              }
            }
          }
          mouseX = rand(100,W-100); mouseY = rand(100,H-100);
        }
      }
    }

    ctx.clearRect(0,0,W,H);
    drawBackground(ctx,W,H);
    for(const s of splats) s.draw(ctx);
    for(const p of pies) p.draw(ctx);
    drawCannons(ctx);
    if(mouseBought){ drawMouse(ctx); }

    requestAnimationFrame(loop);
  }

  function drawBackground(ctx,W,H){
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(0,H-80,W,80);
    ctx.beginPath(); ctx.moveTo(0,H-80); ctx.lineTo(W,H-80); ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.stroke();
    ctx.restore();
  }

  function drawCannons(ctx){
    const baseX = 24;
    for(let i=0;i<launchers.length;i++){
      const l = launchers[i];
      const y = Math.max(l.y, 100);
      ctx.beginPath(); ctx.ellipse(baseX+6,y+18,18,6,0,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fill();
      ctx.save(); ctx.translate(baseX,y);
      ctx.fillStyle='#263238'; ctx.fillRect(-8, -10, 28, 20);
      ctx.fillStyle='#1b2330'; ctx.fillRect(16, -6, 40, 12);
      ctx.fillStyle='#98a1b3'; ctx.fillRect(-6,-8,4,16);
      ctx.restore();
      ctx.fillStyle='rgba(255,255,255,0.75)'; ctx.font='12px sans-serif'; ctx.fillText('Cannon', baseX+64, y+6);
    }
  }

  function drawMouse(ctx){
    ctx.save(); ctx.translate(mouseX,mouseY);
    ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    ctx.beginPath(); ctx.moveTo(-4,-4); ctx.lineTo(14,0); ctx.lineTo(-4,4); ctx.closePath(); ctx.fillStyle='#000'; ctx.fill();
    ctx.restore();
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>